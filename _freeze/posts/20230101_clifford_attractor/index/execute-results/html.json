{
  "hash": "40424ac0b6c643b22bc86c8969a9cb90",
  "result": {
    "markdown": "---\ntitle: \"Clifford Attractor\"\nauthor: \"Bob\"\ndate: \"2023-01-01\"\ncategories: [modelling, code, R, chaos]\nimage: pics/pic_606.png\nexecute: \n  eval: false\nformat:\n  html:\n    code-fold: true\n    code-overflow: scroll\n    code-summary: show the code\n    code-line-numbers: true\n---\n\n\nInspired by [this](https://fronkonstin.com/2017/11/07/drawing-10-million-points-with-ggplot-clifford-attractors/) blog post. The *R* code below creates the individual video frames (a [Clifford](http://paulbourke.net/fractals/clifford/) attractor where one of the four parameters is stepped along with the frame count), which are then knitted together using *FFMPEG*.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube-nocookie.com/embed/wK6wuTOnhbM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Rcpp)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(foreach)\nlibrary(doParallel)\nregisterDoParallel(parallel::detectCores())\n\npic_dir <- \"pics\"\noutput_video <- \"output.mp4\"\n\nopt = theme(legend.position  = \"none\",\n            panel.background = element_rect(fill=\"black\"),\n            plot.margin = margin(0, 0, -8, -8, unit = \"pt\"),\n            axis.ticks       = element_blank(),\n            panel.grid       = element_blank(),\n            axis.title       = element_blank(),\n            axis.text        = element_blank())\n\ncppFunction('DataFrame createTrajectory(int n, double x0, double y0, \n            double a, double b, double c, double d) {\n            // create the columns\n            NumericVector x(n);\n            NumericVector y(n);\n            x[0]=x0;\n            y[0]=y0;\n            for(int i = 1; i < n; ++i) {\n            x[i] = sin(a*y[i-1])+c*cos(a*x[i-1]);\n            y[i] = sin(b*x[i-1])+d*cos(b*y[i-1]);\n            }\n            // return a new data frame\n            return DataFrame::create(_[\"x\"]= x, _[\"y\"]= y);\n            }\n            ')\n\n# attractor parameters\na=-1.24458046630025\nb=-1.25191834103316 \nc=-1.81590817030519 \nd=-1.90866735205054\n\n# video settings\nfps <- 60\nduration_secs <- 30\nfrac_change <- 2 # fractional change in \"a\" param over course of video\n\nmax_a <- a + (a*frac_change/2)\nmin_a <- a - (a*frac_change/2)\n\na_vec <- seq(from = min_a, to = max_a, by = (a*frac_change)/((fps-1)*duration_secs)) \n\n# loop over parameter, write out png\nforeach (i = 1:length(a_vec)) %dopar% {\n  filename <- file.path(pic_dir, paste0(\"pic_\", i, \".png\"))\n  df = createTrajectory(10000000, 0, 0, a_vec[i], b, c, d)\n  p <- ggplot(df, aes(x, y)) + geom_point(color = \"white\", shape = 46, alpha = .3) + opt\n  \n  ggsave(plot = p, filename = filename, width = 10.8, height = 10.8, dpi = 100)\n}\n\n#### FFMPEG ####\ncommand <- paste0(\"ffmpeg -y -r \", fps, \" -f image2 -s 1080x1080 -i \", pic_dir,\n                  \"/pic_%d.png -vcodec libx264 -crf 25 -pix_fmt yuv420p \", output_video)\nsystem(command = command)\n\n# unlink(pic_dir, recursive = TRUE) # tidy up\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}